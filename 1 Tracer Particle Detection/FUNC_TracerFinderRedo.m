function [MT_DATA,IMAGES] = FUNC_TracerFinderRedo(TRACER_PATH, parameters, N)
%%FUNC_TRACERFINDERREDO Using the detection PARAMETERS structured as 
%%[LENGTH WIDTH pixelMin pixelMax ANGULAR_RESOLUTION], this function
%%detects microtubules in the images stored in TRACER_PATH over the first N
%%frames. The locations, sizes, and orientations of these objects are
%%stored in a structure of structures, one for each frame, stored in
%%MT_DATA. IMAGES is a 3D array containing all images and can be used for
%%plotting in other scripts without having to reload each image.
%%
%Split detection parameters
LENGTH = parameters(1);
WIDTH = parameters(2);
pixelMin = parameters(3);
pixelMax = parameters(4);
ANGULAR_RESOLUTION = parameters(5);

%Get files info
FILES = dir([TRACER_PATH '\*.tif']);

%Define total number of frames to be iterated over. Using min ensures that
%the script does not run over for small data sets.
if nargin == 2
    FRAMES_TOTAL = length(FILES);
elseif nargin == 3
    FRAMES_TOTAL = min(N,length(FILES));
end

%Initialize storage location for all MTs and images
MT_DATA = struct();
% IMAGES = [];
IMAGE = imread(fullfile(TRACER_PATH, FILES(1).name));
IMAGES = zeros(size(IMAGE,1), size(IMAGE,2), FRAMES_TOTAL);
% allBinaries = IMAGES;
%%
    %%Iterate through each frame and detect objects
    for currFrame = 1:FRAMES_TOTAL

        %Load new image
        IMAGE = imread(fullfile(TRACER_PATH, FILES(currFrame).name));

        %Approximate a MT as a 2D Gaussian with x and y variances WIDTH and
        %LENGTH
        BOUNDING_BOX_SIZE = round(LENGTH*2);
        TEMPLATES = FUNC_Generate_2DGauss(BOUNDING_BOX_SIZE, WIDTH, LENGTH, ANGULAR_RESOLUTION);

        %Convolve the image with a microtubule (MT) with properties LENGTH and WIDTH
        %NOTE: at bin 2, a MT is ~5 pixels wide, with a halfwidth of about 2 pixels
        BINARY = getConvolvedBinaryImage(TEMPLATES, IMAGE);
%         allBinaries(:,:,currFrame) = BINARY;

        %Detect valid microtubule candidates in the binarized image and
        %select those within acceptable size ranges
        MTs = getObjectsFromBinary(pixelMin, pixelMax, BINARY);

        %Store MTs object for current frame in allMTs superstructure
        MT_DATA(currFrame).MTs = MTs;

        %Store image in image matrix
        IMAGES(:,:,currFrame) = IMAGE;
    end

end

%% Additional Functions
%%
function [BINARY] = getConvolvedBinaryImage(TEMPLATES, IMAGE)
%%This function returns a binary image with potential MT objects separated
%%from background. It is generated by convolving a synthetic microtubule at
%%various orientations, stored as matrices in TEMPLATES, over the
%%unprocessed IMAGE.

    %Initialize binary image matrix 
    BINARY_temp = zeros(size(IMAGE,1), size(IMAGE,2), size(TEMPLATES,3));
    %Reiterate dimension of concolving map
    BOUNDING_BOX_SIZE = size(TEMPLATES,1);
    
    %correlate and binarize each angle
    for aa = 1:size(TEMPLATES,3)
        TEMP_CORR = normxcorr2(TEMPLATES(:,:,aa),IMAGE);
        TEMP_CORR = TEMP_CORR((BOUNDING_BOX_SIZE/2):(end-(BOUNDING_BOX_SIZE/2)), ...
            (BOUNDING_BOX_SIZE/2):(end-(BOUNDING_BOX_SIZE/2)));

        %Determine if images is 8-bit or 16-bit
        if max(max(IMAGE)) > 255
            U_CROSS_CORR = uint16((65535/2)*(TEMP_CORR+1) );
        else
            U_CROSS_CORR = uint8((255/2)*(TEMP_CORR+1) );
        end
    %THIS 0.35 IS NORMALLY 0.2, IF YOU ARE READING THIS, CHANGE IT
    %BACK!! IT's ONLY 0.35 FOR 1% PEG BECAUSE OF IMAGING ISSUES
        BINARY_temp(:,:,aa) = imbinarize(U_CROSS_CORR,adaptthresh(U_CROSS_CORR, 0.2));

    end

    %Combine detected objects over all angles (360/ANGULAR_RESOLUTION
    %layers)
    BINARY = sum(BINARY_temp(:,:,:),3);

end
%%
function [MTs] = getObjectsFromBinary(pixelMin, pixelMax, BINARY)
%%This function returns a structure containing the dimensions and locations
%%of microtubules detected in the binarized image BINARY. PIXELMIN and
%%PIXELMAX are cutoff values (scalars) used to remove microtubules above or 
%%below critical sizes.

    %Compute the areas of connected components:
    CC = bwconncomp(BINARY);
    MTs = regionprops(CC, 'Area');

    %Remove >pixelMax and <pixelMin pixel objects:
    L = labelmatrix(CC);
    BINARY = ismember(L, find(  [MTs.Area] >= pixelMin  &  [MTs.Area] <= pixelMax   )   );
    CC = bwconncomp(BINARY);
    MTs = regionprops(CC, 'centroid','MajorAxisLength','Orientation','MinorAxisLength');

    % Remove data from S if it's not microtubule shaped
    removeElmt = [];
    for q = 1:length([MTs.MajorAxisLength])
        if MTs(q).MajorAxisLength < 4*MTs(q).MinorAxisLength    %%Selects for "length to width ratio"
                %    TRACER_DATA(q,:) = [];
           removeElmt = [removeElmt q];
        end
    end
    MTs(removeElmt) = [];
    
end