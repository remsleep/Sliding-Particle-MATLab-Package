function [WIDTH,LENGTH,pixelMin,pixelMax] = FUNC_TracerParamTester(TRACER_PATH, ANGULAR_RESOLUTION, N)
%FUNC_TRACERPARAMTESTER Allows the user to iteratively view the first N frames of
%their data and change detection parameters. TRACER_PATH is the directory
%in which your data resides. ANGULAR_RESOLUTION is the interval in degrees
%over which your synthetic microtubule will be convolved and rotated.

%% Preliminary initializations
%Initialize default microtubule (MT) length and width
LENGTH = 5;
WIDTH = 3;

%Define default limits of acceptable synthetic MT pixel sizes
pixelMin = 50;
pixelMax = 2000;

%Store file info
FILES = dir([TRACER_PATH '\*.tif']);

%Define total number of frames to be iterated over. Using min ensures that
%the script does not run over for small data sets.
FRAMES_TOTAL = min(N,length(FILES));

%Location for all MTs and images for plotting
allMTs = struct();
IMAGE = imread(fullfile(TRACER_PATH, FILES(1).name));
allImages = zeros(size(IMAGE,1), size(IMAGE,2), N);
allBinaries = allImages;

%Define variable to indicate inputted parameters are good
notSatisfied = 1;

%% Finding suitable parameters
%Begin loop to search for acceptable length and width parameters
while notSatisfied
    
    %Iterate through each frame
    for currFrame = 1:FRAMES_TOTAL

        %Load new image
        IMAGE = imread(fullfile(TRACER_PATH, FILES(currFrame).name));
        
        %Approximate a MT as a 2D Gaussian with x and y variances WIDTH and
        %LENGTH
        BOUNDING_BOX_SIZE = round(LENGTH*2);
        TEMPLATES = FUNC_Generate_2DGauss(BOUNDING_BOX_SIZE, WIDTH, LENGTH, ANGULAR_RESOLUTION);

        %Convolve the image with a microtubule (MT) with properties LENGTH and WIDTH
        %NOTE: at bin 2, a MT is ~5 pixels wide, with a halfwidth of about 2 pixels
        BINARY = getConvolvedBinaryImage(TEMPLATES, IMAGE);
        allBinaries(:,:,currFrame) = BINARY;
        
        %Detect valid microtubule candidates in the binarized image and
        %select those within acceptable size ranges
        MTs = getObjectsFromBinary(pixelMin, pixelMax, BINARY);

        %Store MTs object for current frame in allMTs superstructure
        allMTs(currFrame).MTs = MTs;
        
        %Store image in image matrix
        allImages(:,:,currFrame) = IMAGE;
    end

    figure()
    %Plot all valid MTs superimposed over image
    for currFrame = 1:FRAMES_TOTAL
        %Overlay detected objects
        subplot(1,2,1)
        plotObjects(allMTs(currFrame).MTs, allImages(:,:,currFrame))
        subplot(1,2,2)
        imshow(allBinaries(:,:,currFrame))
        pause(.1)
    end
    
    %Get user's response
    [LENGTH, WIDTH, pixelMin, pixelMax, notSatisfied] = ...
        updateParameters(LENGTH, WIDTH, pixelMin, pixelMax);
    close
    
end
        
end 

%% Additional Functions

%%
function [BINARY] = getConvolvedBinaryImage(TEMPLATES, IMAGE)
%%This function returns a binary image with potential MT objects separated
%%from background. It is generated by convolving a synthetic microtubule at
%%various orientations, stored as matrices in TEMPLATES, over the
%%unprocessed IMAGE.

    %Initialize binary image matrix 
    BINARY_temp = zeros(size(IMAGE,1), size(IMAGE,2), size(TEMPLATES,3));
    %Reiterate dimension of concolving map
    BOUNDING_BOX_SIZE = size(TEMPLATES,1);
    
    %correlate and binarize each angle
    for aa = 1:size(TEMPLATES,3)
        TEMP_CORR = normxcorr2(TEMPLATES(:,:,aa),IMAGE);
        TEMP_CORR = TEMP_CORR((BOUNDING_BOX_SIZE/2):(end-(BOUNDING_BOX_SIZE/2)), ...
            (BOUNDING_BOX_SIZE/2):(end-(BOUNDING_BOX_SIZE/2)));

        %TEMP_CORR = wiener2(TEMP_CORR,[2 2]); %Blur
        U16_CROSS_CORR = uint16((65535/2)*(TEMP_CORR+1) );
    %THIS 0.35 IS NORMALLY 0.2, IF YOU ARE READING THIS, CHANGE IT
    %BACK!! IT's ONLY 0.35 FOR 1% PEG BECAUSE OF IMAGING ISSUES
        BINARY_temp(:,:,aa) = imbinarize(U16_CROSS_CORR,adaptthresh(U16_CROSS_CORR, 0.2));

    end

    %Combine detected objects over all angles (360/ANGULAR_RESOLUTION
    %layers)
    BINARY = sum(BINARY_temp(:,:,:),3);

end
%%
function [MTs] = getObjectsFromBinary(pixelMin, pixelMax, BINARY)
%%This function returns a structure containing the dimensions and locations
%%of microtubules detected in the binarized image BINARY. PIXELMIN and
%%PIXELMAX are cutoff values (scalars) used to remove microtubules above or 
%%below critical sizes.

    %Compute the areas of connected components:
    CC = bwconncomp(BINARY);
    MTs = regionprops(CC, 'Area');
    
    %Remove >pixelMax and <pixelMin pixel objects:
    L = labelmatrix(CC);
    BINARY = ismember(L, find(  [MTs.Area] >= pixelMin  &  [MTs.Area] <= pixelMax   )   );
    CC = bwconncomp(BINARY);
    MTs = regionprops(CC, 'centroid','MajorAxisLength','Orientation','MinorAxisLength');

    % Remove data from S if it's not microtubule shaped
    removeElmt = [];
    for q = 1:length([MTs.MajorAxisLength])
        if MTs(q).MajorAxisLength < 4*MTs(q).MinorAxisLength    %%Selects for "length to width ratio"
                %    TRACER_DATA(q,:) = [];
           removeElmt = [removeElmt q];
        end
    end
    MTs(removeElmt) = [];
    
end
%%
function [] = plotObjects(MTs, IMAGE)
%%This function plots all objects in the current frame over IMAGE. MTs is
%%an structure containing fields of all MTs detected in the current IMAGE
%%from FUNC_TracerFinder.

    %plot the extracted info over the image
    %autocontrast scale the image
    imcontrastscale(1)=min(min(IMAGE));
    imcontrastscale(2)=mean(mean(IMAGE))*2;

    %Plot Centroids and Sticks and Ellipses
    order=10;
    phi = linspace(0,2*pi,50); cosphi = cos(phi); sinphi = sin(phi);
    colormap ('gray'), imshow(IMAGE,imcontrastscale);
%     colormap ('gray'), imshow(IMAGE);
    hold on
    for currMT = 1:length(MTs)
        %Stick
        x1 = MTs(currMT).Centroid(1) + cos(deg2rad(pi-MTs(currMT).Orientation)).*order;
        y1 = MTs(currMT).Centroid(2) + sin(deg2rad(pi-MTs(currMT).Orientation)).*order;
        x2 = MTs(currMT).Centroid(1) - cos(deg2rad(pi-MTs(currMT).Orientation)).*order;
        y2 = MTs(currMT).Centroid(2) - sin(deg2rad(pi-MTs(currMT).Orientation)).*order;
        plot([x1 x2], [y1 y2], 'LineWidth',2, 'color','r');
        %Ellipse
        xbar = MTs(currMT).Centroid(1);  ybar = MTs(currMT).Centroid(2);
        a = MTs(currMT).MajorAxisLength/2;   b = MTs(currMT).MinorAxisLength/2;
        theta = pi*MTs(currMT).Orientation/180;
        R = [ cos(theta)   sin(theta)
            -sin(theta)   cos(theta)];
        xy = [a*cosphi; b*sinphi];  xy = R*xy;
        x = xy(1,:) + xbar;  y = xy(2,:) + ybar;
        plot(x,y,'r','LineWidth',2);
    end
    hold off
end
%%
function [LENGTH, WIDTH, pixelMin, pixelMax, notSatisfied] = ...
        updateParameters(LENGTH, WIDTH, pixelMin, pixelMax)

    %Reset parameter change trigger
    stringtrigger = -1;
    possibleResponses = ['1', 'yes', 'Yes', '0', 'no', 'No'];

    fprintf('\n');
    while ~ismember(stringtrigger, possibleResponses)
        %Adjust LENGTH and WIDTH, if necessary
        fprintf('Current MT LENGTH: %d; Current MT WIDTH: %d.\nWould you like new values? ',...
            LENGTH,WIDTH);
        stringtrigger = input('Please type response: ','s');
        if ismember(stringtrigger, possibleResponses(1:7))
            LENGTH = input('Please input a new LENGTH: '); 
            WIDTH = input('Please input a new WIDTH: ');
            notSatisfied = 1;
        else
            notSatisfied = 0;
        end
        %Adjust pixelMin and pixelMax, if necessary
        fprintf('Current MT pixelMin: %d; Current MT pixelMax: %d.\nWould you like new values? ',...
            pixelMin,pixelMax);
        stringtrigger = input('Please type response: ','s');
        if ismember(stringtrigger, possibleResponses(1:7))
            pixelMin = input('Please input a new pixelMin: ');
            pixelMax = input('Please input a new pixelMax: '); 
            stringtrigger = 'y';
            notSatisfied = 1;
        elseif ismember(stringtrigger, possibleResponses(8:end)) && (notSatisfied == 0)
            notSatisfied = 0;
        end
    end
    
end